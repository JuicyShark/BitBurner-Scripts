"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = exports.autocomplete = void 0;
const argsSchema = [
    ['github', 'JuicyShark'],
    ['repository', 'BitBurner-Scripts'],
    ['branch', 'main'],
    ['download', []],
    ['new-file', []],
    ['subfolder', ''], // Can be set to download to a sub-folder that is not part of the remote repository structure
];
function autocomplete(data, _) {
    data.flags(argsSchema);
    return [];
}
exports.autocomplete = autocomplete;
/** @param {NS} ns
* Will try to download a fresh version of every file on the current server.
* You are responsible for:
* - Backing up your save / scripts first (try `download *` in the terminal)
* - Ensuring you have no local changes that you don't mind getting overwritten
* TODO: Some way to list all files in the repository and/or download them all. **/
function main(ns) {
    return __awaiter(this, void 0, void 0, function* () {
        const options = ns.flags(argsSchema);
        const baseUrl = `https://raw.githubusercontent.com/${options.github}/${options.repository}/${options.branch}/`;
        const filesToDownload = options['new-file'].concat(options.download.length > 0 ? options.download : ns.ls('home')
            .filter(name => !name.endsWith(".exe") && !name.endsWith(".msg") && !name.endsWith(".lit")));
        for (const localFilePath of filesToDownload) {
            const remoteFilePath = baseUrl + localFilePath.substr(options.subfolder.length);
            ns.print(`Trying to update "${localFilePath}" from ${remoteFilePath} ...`);
            if (yield ns.wget(`${remoteFilePath}?ts=${new Date().getTime()}`, localFilePath))
                ns.tprint(`SUCCESS: Updated "${localFilePath}" to the latest from ${remoteFilePath}`);
            else
                ns.tprint(`WARNING: "${localFilePath}" was not updated. (Currently running or not located at ${remoteFilePath} )`);
        }
    });
}
exports.main = main;
//# sourceMappingURL=syncGit.js.map